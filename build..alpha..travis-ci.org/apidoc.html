<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

    >babel-plugin-transform-runtime (v6.23.0)</a>
</h1>
<h4>Externalise references to helpers and builtins, automatically polyfilling your code without polluting globals</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.babel-plugin-transform-runtime">module babel-plugin-transform-runtime</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">babel-plugin-transform-runtime.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.babel-plugin-transform-runtime.default">
            function <span class="apidocSignatureSpan">babel-plugin-transform-runtime.</span>default
            <span class="apidocSignatureSpan">(_ref)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">babel-plugin-transform-runtime.</span>definitions</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.babel-plugin-transform-runtime" id="apidoc.module.babel-plugin-transform-runtime">module babel-plugin-transform-runtime</a></h1>




    <h2>
        <a href="#apidoc.element.babel-plugin-transform-runtime.default" id="apidoc.element.babel-plugin-transform-runtime.default">
        function <span class="apidocSignatureSpan">babel-plugin-transform-runtime.</span>default
        <span class="apidocSignatureSpan">(_ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (_ref) {
  var t = _ref.types;

  function getRuntimeModuleName(opts) {
    return opts.moduleName || &#x22;babel-runtime&#x22;;
  }

  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  var HELPER_BLACKLIST = [&#x22;interopRequireWildcard&#x22;, &#x22;interopRequireDefault&#x22;];

  return {
    pre: function pre(file) {
      var moduleName = getRuntimeModuleName(this.opts);

      if (this.opts.helpers !== false) {
        file.set(&#x22;helperGenerator&#x22;, function (name) {
          if (HELPER_BLACKLIST.indexOf(name) &#x3c; 0) {
            return file.addImport(moduleName + &#x22;/helpers/&#x22; + name, &#x22;default&#x22;, name);
          }
        });
      }

      this.setDynamic(&#x22;regeneratorIdentifier&#x22;, function () {
        return file.addImport(moduleName + &#x22;/regenerator&#x22;, &#x22;default&#x22;, &#x22;regeneratorRuntime&#x22;);
      });
    },


    visitor: {
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        var node = path.node,
            parent = path.parent,
            scope = path.scope;


        if (node.name === &#x22;regeneratorRuntime&#x22; &#x26;&#x26; state.opts.regenerator !== false) {
          path.replaceWith(state.get(&#x22;regeneratorIdentifier&#x22;));
          return;
        }

        if (state.opts.polyfill === false) return;

        if (t.isMemberExpression(parent)) return;
        if (!has(_definitions2.default.builtins, node.name)) return;
        if (scope.getBindingIdentifier(node.name)) return;

        var moduleName = getRuntimeModuleName(state.opts);
        path.replaceWith(state.addImport(moduleName + &#x22;/core-js/&#x22; + _definitions2.default.builtins[node.name], &#x22;default&#x22;, node.name
));
      },
      CallExpression: function CallExpression(path, state) {
        if (state.opts.polyfill === false) return;

        if (path.node.arguments.length) return;

        var callee = path.node.callee;
        if (!t.isMemberExpression(callee)) return;
        if (!callee.computed) return;
        if (!path.get(&#x22;callee.property&#x22;).matchesPattern(&#x22;Symbol.iterator&#x22;)) return;

        var moduleName = getRuntimeModuleName(state.opts);
        path.replaceWith(t.callExpression(state.addImport(moduleName + &#x22;/core-js/get-iterator&#x22;, &#x22;default&#x22;, &#x22;getIterator&#x22;), [callee
.object]));
      },
      BinaryExpression: function BinaryExpression(path, state) {
        if (state.opts.polyfill === false) return;

        if (path.node.operator !== &#x22;in&#x22;) return;
        if (!path.get(&#x22;left&#x22;).matchesPattern(&#x22;Symbol.iterator&#x22;)) return;

        var moduleName = getRuntimeModuleName(state.opts);
        path.replaceWith(t.callExpression(state.addImport(moduleName + &#x22;/core-js/is-iterable&#x22;, &#x22;default&#x22;, &#x22;isIterable&#x22;), [path.node
.right]));
      },

      MemberExpression: {
        enter: function enter(path, state) {
          if (state.opts.polyfill === false) return;
          if (!path.isReferenced()) return;

          var node = path.node;

          var obj = node.object;
          var prop = node.property;

          if (!t.isReferenced(obj, node)) return;
          if (node.computed) return;
          if (!has(_definitions2.default.methods, obj.name)) return;

          var methods = _definitions2.default.methods[obj.name];
          if (!has(methods, prop.name)) return;

          if (path.scope.getBindingIdentifier(obj.name)) return;

          if (obj.name === &#x22;Object&#x22; &#x26;&#x26; prop.name === &#x22;defineProperty&#x22; &#x26;&#x26; path.parentPath.isCallExpression()) {
            var call = path.parentPath.node;
            if (call.arguments.length === 3 &#x26;&#x26; t.isLiteral(call.arguments[1])) return;
          }

          var moduleName = getRuntimeModuleName(state.opts);
          path.replaceWith(state.addImport(moduleName + &#x22;/core-js/&#x22; + methods[prop.name], &#x22;default&#x22;, obj.name + &#x22;$&#x22; + prop.name));
        },
        exit: function exit(path, state) {
          if (state.opts.polyfill === false) return;
          if (!path.isReferenced()) return;

          var node = path.node;

          var obj = node.object;

          if (!has(_definitions2.default.builtins, obj.name)) return;
          if (path.scope.getBindingIdentifier(obj.name)) return; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj &#x26;&#x26; obj.__esModule ? obj : { default: obj }; }

var sym = (0, _symbol2.default)();

var promise = new _promise2.<span class="apidocCodeKeywordSpan">default</span>();

console.log((0, _getIterator3.default)(arr));
```

This means is that you can seamlessly use these native built-ins and static methods
without worrying about where they come from.
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
